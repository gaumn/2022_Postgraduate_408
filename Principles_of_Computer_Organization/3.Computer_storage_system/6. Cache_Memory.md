# 高速缓冲存储器

由于程序的转移概率不会很低，数据分布的离散性较大，所以单纯依靠主存系统提高主存系统的频宽是有限的。这就是必须从系统结构上进行改进，即采用存储体系。通常将存储系统分为“Cache-主存”层次和“主存-辅存”层次。

## 程序访问的局部性原理

程序访问的局部性原理包括空间局部性和时间局部性。时间局部性是指在最近的未来要用到的信息，很可能是现在正在使用的信息，因为程序中存在循环。空间局部性是指最近的未来要用到的信息，很有可能与现在正在使用的信息在存储空间上是邻近的，因为指令通常是顺序存放的、顺序执行，数据一般也是以向量、数组等形式簇聚地存储在一起的。

高速缓冲技术就是利用程序访问的局部性原理，把程序中正在使用的部分存放在一个高速的、容量较小的Cache中，使CPU的访存操作大多数针对Cache进行，从而大大地提高了程序的执行速度。

## Cache的基本工作原理

Cache位于存储器层次结构的顶层，通常由SRAM构成。

为了方便Cache与主存之间交换信息，Cache和主存都被划分为相等的块，Cache块又被称为Cache行，每块由若干字节组成，块的长度称为块长(Cache行长)。由于Cache的容量远小于主存的容量，所以Cache中的块数要远小于主存中的块数，它仅保存主存中最活跃的若干块的副本。因此Cache按照某种策略，预测CPU在未来一段时间内欲访存的数据，将其装入Cache。

当CPU发出读请求时，若访存地址在Cache中命中，就将此地址转换为Cache地址，直接对Cache进行读操作，与主存无关；若Cache不命中，则仍需访问主存，并把此字所在的块一次性地从主存调入Cache。若此时Cache已满，则需根据某种替换算法，用这个块替换Cache中原来的某块信息。值得注意的，CPU与Cache之间的数据交换以字为单位，而Cache与主存的数据交换以Cache块为单位。[^注]

[^注]:某些计算机中也采用同时访问Cache和主存的方式，若Cache命中，则主存访问终止；否则访问主存并替换Cache

当CPU发出写请求时，若Cache命中，有可能遇到Cache与主存中的内容不一致的问题。若Cache命中，需要采用一定的写策略处理，常见的处理方法有全写法和写回法。

CPU欲访问的信息已在Cache中的比率称为Cache的命中率。设一个程序执行期间，Cache的总命中次数为N<sub>c</sub>,访问主存的总次数为N<sub>m</sub>，则命中率H为 H=N<sub>c</sub>/(N<sub>c</sub>+N<sub>m</sub>)

可见为了提高访问效率，命中率H越接近1越好。设t<sub>c</sub>为命中时的Cache访问时间，t<sub>m</sub>为未命中时的访问时间，1-H表示未命中率，则Cache-主存系统的平均访问时间T<sub>a</sub>为 T<sub>a</sub>=Ht<sub>c</sub>+(1-H)t<sub>m</sub>

## Cache和主存的映射方式

Cache行中的信息是主存中某个块的副本，地址映射是指把主存地址空间映射到Cache地址空间，即把存放在主存中的信息按照某种规则装入Cache。

由于Cache行数比主存块数少，因此主存中只有一部分块的信息可放在Cache中，因此在Cache中要给每块加一个标记，指明它是主存中那一块的副本。该标记的内容相当于主存中块的编号。为了说明Cache行中的信息是否有效，每个Cache行需要一个有效位。

地址映射不同于地址变换。地址变换是指CPU在访存时，将主存地址按照一定的映射规则换算成Cache地址的过程。地址映射的方法有以下三种：直接映射，全相联映射，组相联映射。

#### 直接映射

主存中的每一块只能装入Cache中的唯一位置。若这个位置已有内容，则产生冲突，原来的块将无条件地被替换出去(无需使用替换算法)。直接映射实现简单，但不够灵活，即使Cache的其他许多地址空着不能占用，这使得直接映射的块冲突概率最高，空间利用率最低。

直接映射的关系可定义为：j= i  mod 2<sup>c</sup>(式中，j为Cache的块号，i为主存的块号，2<SUP>c</SUP>是Cache中的总块数)

给每个Cache行设置一个长为t=m-c的标记(tag)，当主存某块调入Cache后，就将其行号的高t为设置在对应Cache行的标记中。

直接映射的地址结构为：

| 标记 | Cache行号 | 块内地址 |
| ---- | --------- | -------- |

#### 全相联映射

主存中的每一块Cache中的任意位置，每行的标记用于指出该行取自主存的那一块，所以CPU的访存时需要与所有Cache行的标记进行比较。全相联映射方式的优点是比较灵活，Cache块的冲突概率低，空间利用率高，命中率也高；缺点是标记的比较速度较慢，实现成本较高，通常需采用昂贵的按内容寻址的相联存储器进行映射。

全相联映射的地址结构为

| 标记 | 块内地址 |
| ---- | -------- |

#### 组相联映射

将Cache空间分为大小相同的组，主存的一个数据块可以装入一组内的任意位置，即组间采用直接映射，而组内采用全相联映射。它是对直接映射和全相联映射的一种折中，当Q=1时变为全相联映射，当Q=Cache块数时变成直接映射。假设每组有r个Cache行，则称之为r路组相联。

组相联映射的关系可以定义为j=i mod Q(式中j是Cache的组号，i是主存的块号,Q是Cache的组数)。

路数越大，即每组Cache行的数量越大，发生冲突的概率越低，但相联比较电路越复杂。选择适当的数量，可使组相联映射的成本接近直接映射，而性能上接近于全相联映射。

组相联映射的地址结构为

| 标记 | 组号 | 块内地址 |
| ---- | ---- | -------- |

CPU访存过程如下：

+ 根据访存地址中间的组号找到对应的Cache组；
+ 将对应的Cache组中每个行的标记与主存地址的高位标记进行比较
+ 若有一个相等且有效位为1，则访问Cache命中，此时根据主存地址中的块内地址，在对应Cache行存取信息
+ 若不相等或虽相等但有效位为0，则不命中，此时CPU从主存中读出该地址所在的一块信息送到对应的Cache组中的任意一个空闲行中，将有效位置1，并设置标记，同时将该地址中的内容送到CPU中。

三种映射方式中，直接映射的每个主存块只能映射到Cache的某一固定行；全相联映射可以映射到所有的Cache行；N路组相联映射可以映射到N行。当Cache大小、主存块大小一定时，

+ 直接映射的命中率最低，全相联映射的命中率最高
+ 直接映射的判断开销最小，所需时间最短，全相联映射的判断开销最大、所需时间最长
+ 直接映射标记所占的额外空间开销最少，全相联映射标记所占的额外空间开始最大

## Cache中主存块的替换算法

+ 随机算法(RAND)
+ 先进先出算法(FIFO)
+ 近期最少使用算法(LRU)
+ 最不经常使用算法(LFU)

## Cache写策略

因为Cache中的内容是主存块副本，当对Cache中的内容进行更新时，就需选用写操作策略使Cache内容和主存内容保存一致。

对应Cache写命中时，有两种处理方法：全写法(写直通法、write-through)和写回法(write-back)

### 全写法(写直通法、write-through)

当CPU对Cache写命中时，必须把数据同时写入使Cache内容和主存内容保持一致。当某一块需要替换时，不必把这块写回主存，用新调入的块直接覆盖即可。

这种方法实现简单，能随时保持主存数据的正确性。缺点是增加了访存次数，降低了Cache的效率。

写缓冲：为了减少全写法直接写入主存的时间损耗，在Cache和主存之间加了一个缓冲再控制将内容写入主存。写缓冲是一个FIFO队列，写缓冲可以解决速度不匹配的问题，但若出现频繁写时，会使写缓冲饱和溢出。

### 写回法(write-back)

当CPU对Cache命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存，这种方法减少了访存次数，但存在不一致的隐患。采用这种策略，每个Cache行必须设置一个标志位(赃位)，以反映此块是否被CPU修改过。

对于Cache写未命中，也有两种处理方法：写分配法(write-allocate)和非写分配法(not-write-allocate)

### 写分配法(write-allocate)

加载主存中的块到Cache中，然后更新这个Cache块。它试图利用程序的空间局部性，但缺点是每次不命中都需要从主存中读取一块。

### 非写分配法(not-write-allocate)

只写会主存，不进行调块。

非写分配法与全写法合用，写分配法和写回法合用。





































































